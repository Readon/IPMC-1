#!/usr/bin/python3
import csv
import re

class CSVData(object):
	def __init__(self, dictsrc, **kwargs):
		self._data = dict(dictsrc)
		self._data.update(kwargs)
	@staticmethod
	def tokenname(name):
		return re.sub('[^a-zA-Z0-9]','_',name)
	def __getitem__(self, k):
		if k.endswith('Comma'):
			return self[k[:-5]]+','
		if k.endswith('Quote'):
			return self[k[:-5]]+'"'
		if k.startswith('Token'):
			return self.tokenname(self[k[5:]])
		return self._data[k]
	def __getattr__(self, k):
		try:
			return self[k]
		except:
			raise AttributeError('No such key "{}"'.format(k))
	def keys(self):
		return self._data.keys()
	def values(self):
		return self._data.values()
	def items(self):
		return self._data.items()
	def __repr__(self):
		return repr(self._data)

COMPLETION = dict(map(lambda x: (x['Code'],CSVData(x)), csv.DictReader(open('IPMISpec/Completion.csv'))))
NETFN = dict(map(lambda x: (x['NetFn'],CSVData(x)), csv.DictReader(open('IPMISpec/NetFn.csv'))))
COMMAND = dict(map(lambda x: (x['Code'],CSVData(x, NetFn=NETFN[x['Code'][:2]])), csv.DictReader(open('IPMISpec/Command.csv'))))

def maxnamelen(names):
	return max(map(len, names))

################################################################################

Header = r'''
/**
 * \file IPMI.h
 *
 * \warning This file is generated by genspec.py. DO NOT EDIT.
 */

#ifndef SRC_COMMON_ZYNQIPMC_SERVICES_IPMI_IPMI_H_
#define SRC_COMMON_ZYNQIPMC_SERVICES_IPMI_IPMI_H_

#include <xil_types.h>
#include <map>
#include <string>

namespace IPMI {
	namespace NetFn {
		extern const std::map<u8, std::string> id_to_netfn; ///< Mapping for runtime lookups. (Contains only request NetFns.)
		extern const std::map<std::string, u8> netfn_to_id; ///< Mapping for runtime lookups. (Contains only request NetFns.)

		/// NetFn Code Constants
		///@{
'''.lstrip('\n')

netfnfmt = '\t\tconst u8 {{netfn.TokenName:{}s}} = 0x{{netfn.NetFn}};\n'.format(maxnamelen(map(lambda x: x['TokenName'], NETFN.values())))
for code in sorted(NETFN.keys()):
	Header += netfnfmt.format(netfn=NETFN[code])

Header += '''
		///@}

		/**
		 * Convert NetFn code to equivalent Request NetFn
		 * @param netfn A NetFn code
		 * @return The equivalent Request NetFn code
		 */
		static constexpr inline u8 request_netfn(const u8 netfn) { return netfn & 0xfe; };

		/**
		 * Convert NetFn code to equivalent Response NetFn
		 * @param netfn A NetFn cod
		 * @return The equivalent Response NetFn code
		 */
		static constexpr inline u8 response_netfn(const u8 netfn) { return netfn | 0x01; };
	}

	namespace Completion {
		extern const std::map<u8, std::string> id_to_cmplcode; ///< Mapping for runtime lookups.
		extern const std::map<std::string, u8> cmplcode_to_id; ///< Mapping for runtime lookups.

		/// Completion Code Constants
		///@{
'''.lstrip('\n')

cmplfmt = '\t\tconst u8 {{cmpl.TokenDescription:{}s}} = 0x{{cmpl.Code}};\n'.format(maxnamelen(map(lambda x: x['TokenDescription'], COMPLETION.values())))
for code in sorted(COMPLETION.keys()):
	Header += cmplfmt.format(cmpl=COMPLETION[code])

Header += '''
		///@}
	}

	extern const std::map< u16, std::pair<std::string, std::string> > id_to_cmd; ///< Mapping for runtime lookups. (Contains only request commands.)
	extern const std::map<std::string, u16> cmd_to_id; ///< Mapping for runtime lookups.  (Contains only request commands.)

	/**
	 * Convert an IPMI command to an equivalent Request command
	 * @param cmd An IPMI command code
	 * @return The equivalent Request command code
	 */
	static constexpr inline u16 request_cmd(const u16 cmd) { return cmd & 0xfeff; };

	/**
	 * Convert an IPMI command to an equivalent Response command
	 * @param cmdAn IPMI command code
	 * @return The equivalent Response command code
	 */
	static constexpr inline u16 response_cmd(const u8 cmd) { return cmd | 0x0100; };

'''.lstrip('\n')

cmdfmt = '\t\tconst u16 {{cmd.TokenCommand:{}s}} = 0x{{cmd.Code}}; // {{cmd.Mandatory}}\n'.format(maxnamelen(map(lambda x: x['TokenCommand'], COMMAND.values())))

for netfncode, netfn in sorted(NETFN.items()):
	Header += '\tnamespace {netfn.TokenName} {{\n'.format(netfn=netfn)
	section = ''
	for code, data in sorted(COMMAND.items()):
		if code[0:2] != netfn['NetFn']:
			continue
		if data['Section'] != section:
			if section:
				Header += '\t\t///@}\n'
				Header += '\n'
			section = data['Section']
			Header += '\t\t/// {cmd.Section}\n'.format(cmd=data)
			Header += '\t\t///@{\n'
		Header += cmdfmt.format(cmd=data)
	if section:
		Header += '\t\t///@}\n'
	Header += '''
	}

'''.lstrip('\n')

netfnfmt = '\tusing namespace {netfn.TokenName};\n'
for code in sorted(NETFN.keys()):
	Header += netfnfmt.format(netfn=NETFN[code])

Header += '''
}

#endif /* SRC_COMMON_ZYNQIPMC_SERVICES_IPMI_IPMI_H_ */
'''.lstrip('\n')

with open('IPMI.h','w') as fd:
	fd.write(Header)

################################################################################

CPP = r'''
/**
 * \file IPMI.cc
 *
 * \warning This file is generated by genspec.py. DO NOT EDIT.
 */

#include <services/ipmi/IPMI.h>

const std::map<u8, std::string> IPMI::NetFn::id_to_netfn {
'''.lstrip('\n')

netfnfmt = '\t{{{{ IPMI::NetFn::{{netfn.TokenNameComma:{namlenp1}s}} "{{netfn.NameQuote:{namlenp1}s}} }}}},\n'.format(namlenp1=maxnamelen(map(lambda x: x['Name'], NETFN.values()))+1)
for code in sorted(NETFN.keys()):
	CPP += netfnfmt.format(netfn=NETFN[code])

CPP += '''
};

const std::map<std::string, u8> IPMI::NetFn::netfn_to_id {
'''.lstrip('\n')

namelen = maxnamelen(map(lambda x: x['Name'], NETFN.values()))
netfnfmt = '\t{{{{ "{{netfn.NameQuoteComma:{namelenp2}s}} IPMI::NetFn::{{netfn.TokenName:{namlen}s}} }}}},\n'.format(namlen=namelen, namelenp2=namelen+2)
for code in sorted(NETFN.keys()):
	CPP += netfnfmt.format(netfn=NETFN[code])

CPP += '''
};

const std::map<u8, std::string> IPMI::Completion::id_to_cmplcode {
'''.lstrip('\n')

cmplfmt = '\t{{{{ IPMI::Completion::{{cmpl.TokenDescriptionComma:{namlenp1}s}} "{{cmpl.DescriptionQuote:{namlenp1}s}} }}}},\n'.format(namlenp1=maxnamelen(map(lambda x: x['Description'], COMPLETION.values()))+1)
for code in sorted(COMPLETION.keys()):
	CPP += cmplfmt.format(cmpl=COMPLETION[code])

CPP += '''
};

const std::map<std::string, u8> IPMI::Completion::cmplcode_to_id {
'''.lstrip('\n')

namelen = maxnamelen(map(lambda x: x['Description'], COMPLETION.values()))
cmplfmt = '\t{{{{ "{{cmpl.DescriptionQuoteComma:{namelenp2}s}} IPMI::Completion::{{cmpl.TokenDescription:{namelen}s}} }}}},\n'.format(namelen=namelen, namelenp2=namelen+2)
for code in sorted(COMPLETION.keys()):
	CPP += cmplfmt.format(cmpl=COMPLETION[code])

CPP += '''
};

const std::map< u16, std::pair<std::string, std::string> > IPMI::id_to_cmd {
'''.lstrip('\n')

netfn_namelen = maxnamelen(map(lambda x: x['Name'], NETFN.values()))
cmd_namelen = maxnamelen(map(lambda x: x['Command'], COMMAND.values()))
tfn_namelen = maxnamelen(map(lambda x: '{NetFn.Name}::{Command}'.format(**x), COMMAND.values()))
cmdfmt = '\t{{{{ IPMI::{{tfnComma:{tfn_namelenp1}s}} {{{{ "{{cmd.NetFn.NameQuoteComma:{netfn_namelenp2}s}} "{{cmd.CommandQuote:{cmd_namelenp1}}} }}}} }}}},\n'.format(tfn_namelenp1=tfn_namelen+1, netfn_namelenp2=netfn_namelen+2, cmd_namelenp1=cmd_namelen+1)
for code in sorted(COMMAND.keys()):
	CPP += cmdfmt.format(cmd=COMMAND[code], tfnComma='{cmd.NetFn.TokenName}::{cmd.TokenCommand},'.format(cmd=COMMAND[code]))

CPP += '''
};

const std::map<std::string, u16> IPMI::cmd_to_id {
'''.lstrip('\n')

cmd_namelen = maxnamelen(map(lambda x: x['Command'], COMMAND.values()))
tfn_namelen = maxnamelen(map(lambda x: '{NetFn.Name}::{Command}'.format(**x), COMMAND.values()))
cmdfmt = '\t{{{{ "{{cmd.CommandQuoteComma:{cmd_namelenp2}s}} IPMI::{{tfn:{tfn_namelen}s}} }}}},\n'.format(tfn_namelen=tfn_namelen, cmd_namelenp2=cmd_namelen+2)
for code in sorted(COMMAND.keys()):
	CPP += cmdfmt.format(cmd=COMMAND[code], tfn='{cmd.NetFn.TokenName}::{cmd.TokenCommand}'.format(cmd=COMMAND[code]))

CPP += '''
};
'''.lstrip('\n')

with open('IPMI.cc','w') as fd:
	fd.write(CPP)
